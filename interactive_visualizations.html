<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Power Dynamics Visualizations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4a90e2;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }
        .visualization {
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border-radius: 4px;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            visibility: hidden;
            z-index: 1000;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .controls label {
            display: inline-block;
            margin: 5px 10px;
            cursor: pointer;
        }
        .controls input[type="checkbox"] {
            margin-right: 5px;
        }
        svg {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive Power Dynamics Visualizations</h1>
        <p>Explore power structures through interactive D3.js visualizations. Hover over elements for details, drag network nodes, and filter speakers.</p>
        
        <div class="controls" id="speakerControls">
            <strong>Filter Speakers:</strong><br>
            <div id="speakerCheckboxes"></div>
        </div>

        <div class="visualization">
            <h2>1. Speaker Interaction Network</h2>
            <p>Node size = Speaking time, Edge thickness = Transition frequency. Drag nodes to rearrange.</p>
            <div id="networkGraph"></div>
        </div>

        <div class="visualization">
            <h2>2. Speaking Activity Timeline</h2>
            <p>Hover over bars to see episode details. Shows when each speaker was active.</p>
            <div id="timeline"></div>
        </div>

        <div class="visualization">
            <h2>3. Participation Heatmap</h2>
            <p>Shows speaking time across 20 meeting segments. Darker = more speaking time.</p>
            <div id="heatmap"></div>
        </div>

        <div class="visualization">
            <h2>4. Inequality Lorenz Curve</h2>
            <p>Visualizes speaking time inequality. Deviation from diagonal = inequality.</p>
            <div id="lorenz"></div>
        </div>

        <div class="visualization">
            <h2>5. Cumulative Speaking Time</h2>
            <p>Tracks how speaking time accumulates over the meeting.</p>
            <div id="cumulative"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Load data
        let data;
        fetch('d3_visualization_data.json')
            .then(response => response.json())
            .then(jsonData => {
                data = jsonData;
                initializeVisualizations();
            })
            .catch(error => {
                console.error('Error loading data:', error);
                document.body.innerHTML = '<div class="container"><h1>Error</h1><p>Could not load d3_visualization_data.json. Please ensure the file is in the same directory.</p></div>';
            });

        function initializeVisualizations() {
            createNetworkGraph();
            createTimeline();
            createHeatmap();
            createLorenzCurve();
            createCumulativeChart();
            createSpeakerControls();
        }

        function createNetworkGraph() {
            const width = 900;
            const height = 700;
            const margin = {top: 20, right: 20, bottom: 20, left: 20};

            const svg = d3.select("#networkGraph")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const simulation = d3.forceSimulation(data.network.nodes)
                .force("link", d3.forceLink(data.network.links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = svg.append("g")
                .selectAll("line")
                .data(data.network.links)
                .join("line")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", d => Math.sqrt(d.value) * 2);

            const node = svg.append("g")
                .selectAll("circle")
                .data(data.network.nodes)
                .join("circle")
                .attr("r", d => Math.sqrt(d.speaking_time) / 3)
                .attr("fill", "#69b3a2")
                .attr("stroke", "#333")
                .attr("stroke-width", 1.5)
                .call(drag(simulation))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `${d.id}<br>Speaking Time: ${d.speaking_time.toFixed(1)}s (${d.percentage.toFixed(1)}%)<br>Turns: ${d.turn_count}`);
                })
                .on("mouseout", hideTooltip);

            const label = svg.append("g")
                .selectAll("text")
                .data(data.network.nodes)
                .join("text")
                .text(d => d.id)
                .attr("font-size", "10px")
                .attr("dx", d => Math.sqrt(d.speaking_time) / 3 + 5)
                .attr("dy", 4);

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }

                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }

                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }
        }

        function createTimeline() {
            const width = 1000;
            const height = 400;
            const margin = {top: 20, right: 20, bottom: 40, left: 100};

            const svg = d3.select("#timeline")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const x = d3.scaleLinear()
                .domain([0, data.metadata.meeting_duration])
                .range([margin.left, width - margin.right]);

            const speakers = [...new Set(data.timeline.map(d => d.speaker))].slice(0, 10);
            const y = d3.scaleBand()
                .domain(speakers)
                .range([margin.top, height - margin.bottom])
                .padding(0.1);

            const color = d3.scaleOrdinal(d3.schemeCategory20);

            svg.append("g")
                .selectAll("rect")
                .data(data.timeline.filter(d => speakers.includes(d.speaker)))
                .join("rect")
                .attr("x", d => x(d.start))
                .attr("y", d => y(d.speaker))
                .attr("width", d => x(d.end) - x(d.start))
                .attr("height", y.bandwidth())
                .attr("fill", d => color(d.speaker))
                .attr("opacity", 0.7)
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("opacity", 1);
                    showTooltip(event, `${d.speaker}<br>${d.start.toFixed(1)}s - ${d.end.toFixed(1)}s<br>Duration: ${d.duration.toFixed(1)}s`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("opacity", 0.7);
                    hideTooltip();
                });

            svg.append("g")
                .attr("transform", `translate(0,${margin.top})`)
                .call(d3.axisLeft(y));

            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickFormat(d => `${(d/60).toFixed(1)}m`));
        }

        function createHeatmap() {
            const width = 1000;
            const height = 600;
            const margin = {top: 100, right: 50, bottom: 50, left: 150};

            const svg = d3.select("#heatmap")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const speakers = data.participation_heatmap.data.map(d => d.speaker);
            const segments = data.participation_heatmap.n_segments;

            const x = d3.scaleBand()
                .domain(d3.range(segments))
                .range([margin.left, width - margin.right])
                .padding(0.05);

            const y = d3.scaleBand()
                .domain(speakers)
                .range([margin.top, height - margin.bottom])
                .padding(0.05);

            const maxTime = d3.max(data.participation_heatmap.data, d => 
                d3.max(d.segments, s => s.time));

            const color = d3.scaleSequential(d3.interpolateYlOrRd)
                .domain([0, maxTime]);

            svg.append("g")
                .selectAll("rect")
                .data(data.participation_heatmap.data.flatMap(d => 
                    d.segments.map(s => ({speaker: d.speaker, segment: s.segment, time: s.time}))
                ))
                .join("rect")
                .attr("x", d => x(d.segment))
                .attr("y", d => y(d.speaker))
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .attr("fill", d => color(d.time))
                .attr("stroke", "#fff")
                .attr("stroke-width", 0.5)
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("stroke-width", 2);
                    showTooltip(event, `${d.speaker}<br>Segment ${d.segment + 1}<br>${d.time.toFixed(1)}s`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("stroke-width", 0.5);
                    hideTooltip();
                });

            svg.append("g")
                .attr("transform", `translate(0,${margin.top})`)
                .call(d3.axisLeft(y));

            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisTop(x).tickFormat(d => d + 1));
        }

        function createLorenzCurve() {
            const width = 600;
            const height = 600;
            const margin = {top: 60, right: 20, bottom: 60, left: 60};

            const svg = d3.select("#lorenz")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const x = d3.scaleLinear()
                .domain([0, 1])
                .range([margin.left, width - margin.right]);

            const y = d3.scaleLinear()
                .domain([0, 1])
                .range([height - margin.bottom, margin.top]);

            const line = d3.line()
                .x(d => x(d.cumulative_speakers))
                .y(d => y(d.cumulative_time))
                .curve(d3.curveMonotoneX);

            const equalityLine = d3.line()
                .x(d => x(d.cumulative_speakers))
                .y(d => y(d.perfect_equality))
                .curve(d3.curveLinear);

            const area = d3.area()
                .x(d => x(d.cumulative_speakers))
                .y0(d => y(d.perfect_equality))
                .y1(d => y(d.cumulative_time))
                .curve(d3.curveMonotoneX);

            svg.append("path")
                .datum(data.lorenz_curve)
                .attr("fill", "rgba(0,0,0,0.2)")
                .attr("d", area);

            svg.append("path")
                .datum(data.lorenz_curve)
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 2)
                .attr("d", line);

            svg.append("path")
                .datum(data.lorenz_curve)
                .attr("fill", "none")
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5")
                .attr("d", equalityLine);

            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickFormat(d3.format(".0%")));

            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).tickFormat(d3.format(".0%")));

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height - 10)
                .attr("text-anchor", "middle")
                .text("Cumulative Proportion of Speakers");

            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 15)
                .attr("x", -height / 2)
                .attr("text-anchor", "middle")
                .text("Cumulative Proportion of Speaking Time");

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", margin.top - 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "16px")
                .text(`Gini Coefficient: ${Math.abs(data.inequality_metrics.gini_coefficient).toFixed(3)}`);
        }

        function createCumulativeChart() {
            const width = 1000;
            const height = 500;
            const margin = {top: 20, right: 100, bottom: 40, left: 60};

            const svg = d3.select("#cumulative")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const x = d3.scaleLinear()
                .domain([0, data.metadata.meeting_duration])
                .range([margin.left, width - margin.right]);

            const maxCumulative = d3.max(data.cumulative, d => d.cumulative_time);
            const y = d3.scaleLinear()
                .domain([0, maxCumulative])
                .range([height - margin.bottom, margin.top]);

            const color = d3.scaleOrdinal(d3.schemeCategory10);

            // Calculate cumulative data
            const cumulativeBySpeaker = {};
            data.timeline.forEach(d => {
                if (!cumulativeBySpeaker[d.speaker]) {
                    cumulativeBySpeaker[d.speaker] = [];
                }
            });

            const topSpeakers = Object.keys(data.speaker_times)
                .sort((a, b) => data.speaker_times[b] - data.speaker_times[a])
                .slice(0, 8);

            topSpeakers.forEach(speaker => {
                let cumulative = 0;
                const points = [];
                data.timeline
                    .filter(d => d.speaker === speaker)
                    .sort((a, b) => a.start - b.start)
                    .forEach(d => {
                        cumulative += d.duration;
                        points.push({time: d.end, cumulative: cumulative});
                    });
                cumulativeBySpeaker[speaker] = points;
            });

            const line = d3.line()
                .x(d => x(d.time))
                .y(d => y(d.cumulative))
                .curve(d3.curveMonotoneX);

            topSpeakers.forEach((speaker, i) => {
                const points = cumulativeBySpeaker[speaker];
                if (points.length > 0) {
                    svg.append("path")
                        .datum(points)
                        .attr("fill", "none")
                        .attr("stroke", color(i))
                        .attr("stroke-width", 2)
                        .attr("d", line)
                        .on("mouseover", function() {
                            d3.select(this).attr("stroke-width", 3);
                            showTooltip(d3.event, `${speaker}<br>Total: ${data.speaker_times[speaker].toFixed(1)}s`);
                        })
                        .on("mouseout", function() {
                            d3.select(this).attr("stroke-width", 2);
                            hideTooltip();
                        });
                }
            });

            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickFormat(d => `${(d/60).toFixed(1)}m`));

            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y));

            // Legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width - margin.right + 10}, ${margin.top})`);

            topSpeakers.forEach((speaker, i) => {
                const legendItem = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);
                
                legendItem.append("line")
                    .attr("x1", 0)
                    .attr("x2", 15)
                    .attr("stroke", color(i))
                    .attr("stroke-width", 2);

                legendItem.append("text")
                    .attr("x", 20)
                    .attr("y", 4)
                    .attr("font-size", "10px")
                    .text(speaker);
            });
        }

        function createSpeakerControls() {
            const container = d3.select("#speakerCheckboxes");
            const speakers = Object.keys(data.speaker_times).sort();
            
            speakers.forEach(speaker => {
                container.append("label")
                    .html(`<input type="checkbox" value="${speaker}" checked> ${speaker}`)
                    .style("display", "inline-block")
                    .style("margin", "5px 10px");
            });
        }

        function showTooltip(event, content) {
            const tooltip = d3.select("#tooltip");
            tooltip
                .style("visibility", "visible")
                .html(content)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideTooltip() {
            d3.select("#tooltip").style("visibility", "hidden");
        }
    </script>
</body>
</html>
