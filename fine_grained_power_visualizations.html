<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fine-Grained Topic-Speaker Relations - Interactive Visualizations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4a90e2;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }
        .theoretical-note {
            background: #f0f7ff;
            border-left: 4px solid #4a90e2;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .visualization {
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border-radius: 4px;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
            max-width: 400px;
        }
        svg {
            display: block;
            margin: 0 auto;
        }
        .bar {
            cursor: pointer;
        }
        .bar:hover {
            opacity: 1;
            stroke-width: 2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Fine-Grained Topic-Speaker Relations</h1>
        <p><strong>Power as Interactional Structure</strong></p>
        
        <div class="theoretical-note">
            <h3>Analytic Framework</h3>
            <p>This analysis examines power as an <strong>interactional structure</strong> rather than semantic property, focusing on four phenomena:</p>
            <ul>
                <li><strong>Topic Closure Authority:</strong> Who can end topics without contest</li>
                <li><strong>Asymmetric Topical Accountability:</strong> Who is asked to clarify/justify vs who isn't</li>
                <li><strong>Topic Recycling:</strong> Topics that gain traction when repositioned</li>
                <li><strong>Topic Hijacking vs Alignment:</strong> Reframing while preserving legitimacy</li>
            </ul>
        </div>

        <div class="visualization">
            <h2>1. Topic Closure Authority</h2>
            <p><strong>Who can end topics without contest?</strong></p>
            <div id="closureAuthority"></div>
        </div>

        <div class="visualization">
            <h2>2. Asymmetric Topical Accountability</h2>
            <p><strong>Who is asked to clarify/justify? (Epistemic Standing)</strong></p>
            <div id="accountability"></div>
        </div>

        <div class="visualization">
            <h2>3. Topic Hijacking vs Alignment</h2>
            <p><strong>Who reframes topics while preserving legitimacy?</strong></p>
            <div id="hijacking"></div>
        </div>

        <div class="visualization">
            <h2>4. Topic Recycling</h2>
            <p><strong>Topics that gain traction when repositioned</strong></p>
            <div id="recycling"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        let data;
        
        function loadData() {
            fetch('d3_visualization_data.json')
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(jsonData => {
                    data = jsonData;
                    if (data.fine_grained_relations) {
                        initializeVisualizations();
                    } else {
                        showError('Fine-grained relations data not found. Please regenerate d3_visualization_data.json with the updated script.');
                    }
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    showError('Could not load d3_visualization_data.json. <br><br><strong>Solution:</strong> Run <code>python start_local_server.py</code> in this directory, then open this file via http://localhost:8000/fine_grained_power_visualizations.html');
                });
        }
        
        function showError(message) {
            document.body.innerHTML = '<div class="container"><h1>Error Loading Data</h1><div style="background: #fff3cd; padding: 15px; border-radius: 4px; border-left: 4px solid #ffc107;"><p>' + message + '</p></div></div>';
        }
        
        function initializeVisualizations() {
            createClosureAuthority();
            createAccountability();
            createHijacking();
            createRecycling();
        }

        function createClosureAuthority() {
            const width = 1000;
            const height = 600;
            const margin = {top: 20, right: 100, bottom: 60, left: 200};

            const svg = d3.select("#closureAuthority")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const closures = data.fine_grained_relations.topic_closures || [];
            if (closures.length === 0) {
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .text("No closure data available");
                return;
            }

            // Group by speaker
            const closureBySpeaker = {};
            closures.forEach(c => {
                const speaker = c.shifted_by;
                if (!closureBySpeaker[speaker]) {
                    closureBySpeaker[speaker] = {total: 0, uncontested: 0};
                }
                closureBySpeaker[speaker].total++;
                if (c.uncontested) {
                    closureBySpeaker[speaker].uncontested++;
                }
            });

            const speakers = Object.keys(closureBySpeaker)
                .map(s => ({
                    speaker: s,
                    total: closureBySpeaker[s].total,
                    uncontested: closureBySpeaker[s].uncontested,
                    rate: closureBySpeaker[s].uncontested / closureBySpeaker[s].total
                }))
                .sort((a, b) => b.uncontested - a.uncontested)
                .slice(0, 15);

            const y = d3.scaleBand()
                .domain(speakers.map(s => s.speaker))
                .range([margin.top, height - margin.bottom])
                .padding(0.2);

            const x = d3.scaleLinear()
                .domain([0, 1])
                .range([margin.left, width - margin.right]);

            // Draw bars
            speakers.forEach(s => {
                svg.append("rect")
                    .attr("x", margin.left)
                    .attr("y", y(s.speaker))
                    .attr("width", x(s.rate) - margin.left)
                    .attr("height", y.bandwidth())
                    .attr("fill", d3.interpolateRdYlGn(s.rate))
                    .attr("stroke", "#333")
                    .attr("opacity", 0.8)
                    .on("mouseover", function(event) {
                        showTooltip(event, 
                            `${s.speaker}<br>` +
                            `Uncontested Closure Rate: ${(s.rate * 100).toFixed(1)}%<br>` +
                            `Total Closures: ${s.total}<br>` +
                            `Uncontested: ${s.uncontested}`);
                    })
                    .on("mouseout", hideTooltip);

                svg.append("text")
                    .attr("x", x(s.rate) + 5)
                    .attr("y", y(s.speaker) + y.bandwidth() / 2)
                    .attr("dy", "0.35em")
                    .text(`${(s.rate * 100).toFixed(0)}%`)
                    .style("font-size", "10px");
            });

            svg.append("g")
                .attr("transform", `translate(0,${margin.top})`)
                .call(d3.axisLeft(y));

            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickFormat(d3.format(".0%")));
        }

        function createAccountability() {
            const width = 1000;
            const height = 600;
            const margin = {top: 20, right: 150, bottom: 60, left: 200};

            const svg = d3.select("#accountability")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const patterns = data.fine_grained_relations.accountability_patterns || {};
            if (Object.keys(patterns).length === 0) {
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .text("No accountability data available");
                return;
            }

            const speakers = Object.keys(patterns)
                .map(s => ({
                    speaker: s,
                    ...patterns[s],
                    rate: patterns[s].accountability_rate || 0
                }))
                .filter(s => s.topics_proposed && s.topics_proposed.length > 0)
                .sort((a, b) => b.rate - a.rate)
                .slice(0, 15);

            const y = d3.scaleBand()
                .domain(speakers.map(s => s.speaker))
                .range([margin.top, height - margin.bottom])
                .padding(0.2);

            const maxRate = d3.max(speakers, s => s.rate) || 1;
            const x = d3.scaleLinear()
                .domain([0, maxRate])
                .range([margin.left, width - margin.right]);

            speakers.forEach(s => {
                svg.append("rect")
                    .attr("x", margin.left)
                    .attr("y", y(s.speaker))
                    .attr("width", x(s.rate) - margin.left)
                    .attr("height", y.bandwidth())
                    .attr("fill", s.rate > 0.5 ? "#ff6b6b" : s.rate === 0 ? "#51cf66" : "#ffd43b")
                    .attr("stroke", "#333")
                    .attr("opacity", 0.8)
                    .on("mouseover", function(event) {
                        showTooltip(event, 
                            `${s.speaker}<br>` +
                            `Accountability Rate: ${s.rate.toFixed(2)} per topic<br>` +
                            `Topics Proposed: ${s.topics_proposed.length}<br>` +
                            `Clarification Requests: ${s.clarification_requests || 0}<br>` +
                            `Justification Requests: ${s.justification_requests || 0}<br>` +
                            `Evidence Requests: ${s.evidence_requests || 0}`);
                    })
                    .on("mouseout", hideTooltip);

                svg.append("text")
                    .attr("x", x(s.rate) + 5)
                    .attr("y", y(s.speaker) + y.bandwidth() / 2)
                    .attr("dy", "0.35em")
                    .text(`${s.rate.toFixed(2)}`)
                    .style("font-size", "10px");
            });

            svg.append("g")
                .attr("transform", `translate(0,${margin.top})`)
                .call(d3.axisLeft(y));

            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x));
        }

        function createHijacking() {
            const width = 1000;
            const height = 500;
            const margin = {top: 20, right: 100, bottom: 60, left: 200};

            const svg = d3.select("#hijacking")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const hijackings = data.fine_grained_relations.topic_hijackings || [];
            if (hijackings.length === 0) {
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .text("No hijacking data available");
                return;
            }

            const hijackerCounts = {};
            hijackings.forEach(h => {
                const speaker = h.hijacked_by;
                if (!hijackerCounts[speaker]) {
                    hijackerCounts[speaker] = {hijacking: 0, reframing: 0, shift: 0, alignment: 0};
                }
                hijackerCounts[speaker][h.type] = (hijackerCounts[speaker][h.type] || 0) + 1;
            });

            const speakers = Object.keys(hijackerCounts)
                .map(s => ({
                    speaker: s,
                    ...hijackerCounts[s],
                    total: Object.values(hijackerCounts[s]).reduce((a, b) => a + b, 0)
                }))
                .sort((a, b) => (b.hijacking + b.reframing) - (a.hijacking + a.reframing))
                .slice(0, 15);

            const y = d3.scaleBand()
                .domain(speakers.map(s => s.speaker))
                .range([margin.top, height - margin.bottom])
                .padding(0.2);

            const maxTotal = d3.max(speakers, s => s.total) || 1;
            const x = d3.scaleLinear()
                .domain([0, maxTotal])
                .range([margin.left, width - margin.right]);

            speakers.forEach(s => {
                let xPos = margin.left;
                
                // Stack bars
                ['hijacking', 'reframing', 'shift', 'alignment'].forEach((type, i) => {
                    const width = x(s[type]) - margin.left;
                    if (width > 0) {
                        svg.append("rect")
                            .attr("x", xPos)
                            .attr("y", y(s.speaker))
                            .attr("width", width)
                            .attr("height", y.bandwidth())
                            .attr("fill", ['#4a90e2', '#2ecc71', '#e74c3c', '#f39c12'][i])
                            .attr("stroke", "#333")
                            .attr("opacity", 0.8)
                            .on("mouseover", function(event) {
                                showTooltip(event, 
                                    `${s.speaker}<br>` +
                                    `${type}: ${s[type]}`);
                            })
                            .on("mouseout", hideTooltip);
                        xPos += width;
                    }
                });
            });

            svg.append("g")
                .attr("transform", `translate(0,${margin.top})`)
                .call(d3.axisLeft(y));

            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x));
        }

        function createRecycling() {
            const width = 1000;
            const height = 400;
            const margin = {top: 20, right: 100, bottom: 60, left: 200};

            const svg = d3.select("#recycling")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const recycled = data.fine_grained_relations.recycled_topics || [];
            if (recycled.length === 0) {
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .text("No topic recycling cases detected");
                return;
            }

            // Show recycling cases
            const y = d3.scaleBand()
                .domain(recycled.map((r, i) => i.toString()))
                .range([margin.top, height - margin.bottom])
                .padding(0.2);

            recycled.forEach((r, i) => {
                svg.append("text")
                    .attr("x", margin.left)
                    .attr("y", y(i.toString()) + y.bandwidth() / 2)
                    .attr("dy", "0.35em")
                    .text(`${r.original_topic} → ${r.recycled_topic} (${r.original_proposer} → ${r.recycled_proposer})`)
                    .style("font-size", "11px");
            });
        }

        function showTooltip(event, content) {
            const tooltip = d3.select("#tooltip");
            tooltip
                .style("visibility", "visible")
                .html(content)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideTooltip() {
            d3.select("#tooltip").style("visibility", "hidden");
        }

        // Try loading data
        loadData();
    </script>
</body>
</html>
